# 一、概述

在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：

```react
<form>
  <label>
    名字:
    <input type="text" name="name" />
  </label>
  <input type="submit" value="提交" />
</form>
```

此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。

# 二、受控组件

在 HTML 中，表单元素（如`<input>`、 `<textarea>` 和 `<select>`）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 [`setState()`](https://zh-hans.reactjs.org/docs/react-component.html#setstate)来更新。

我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

## 1. input

我们将以受控组件的形式实现一个实时显示用户输入内容的例子：

```react
import { Component } from 'react';

export default class Input extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'please enter',
    };
  }
  // -- events
  handlechange({ target: { value } }) {
    this.setState({ value });
  }
  render() {
    return (
      <form>
        <input
          type='text'
          value={this.state.value}
          onChange={this.handlechange.bind(this)}
        />
        <p>{this.state.value}</p>
      </form>
    );
  }
}
```

显示效果：

![](IMGS/control-component.gif)

由于在表单元素上设置了 `value` 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。由于 `handlechange` 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

使用”受控组件”，每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。例如，我们如果想限制输入全部是大写字母，我们可以将`handlechange` 写为如下：

```react
handlechange(event) {
    // 更新this.state.val
    this.setState({
        val: event.target.value.toUpperCase()
    });
}
```

## 2. textarea

```react
import { Component } from 'react';

export default class Textarea extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: '请用一句话介绍自己...',
    };
  }
  handleChange({ target: { value } }) {
    this.setState({ value });
  }
  handleSubmit(event) {
    alert(this.state.value);
  }
  render() {
    return (
      <form name='myForm' onSubmit={this.handleSubmit.bind(this)}>
        <textarea type='text' value={this.state.value} onChange={this.handleChange.bind(this)} />
        <p><button type='submit'>确定</button></p>
      </form>
    );
  }
}
```

演示效果：

![](IMGS/textarea.gif)

## 3. select

```react
import { Component } from 'react';

export default class Select extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: '',
    };
  }
  handleChange(event) {
    this.setState({
      value: event.target.value,
    });
  }
  render() {
    return (
      <form >
        <select value={this.state.value} onChange={this.handleChange.bind(this)}>
          <option value=''>-请选择您所在的城市-</option>
          <option value='北京'>北京</option>
          <option value='上海'>上海</option>
          <option value='成都'>成都</option>
          <option value='广州'>广州</option>
          <option value='西安'>西安</option>
          <option value='昆明'>昆明</option>
        </select>
        <p>您所在的城市是：{this.state.value}</p>
      </form>
    );
  }
}
```

演示效果：

![](IMGS/select.gif)

总的来说，这使得 `<input type="text">`, `<textarea>` 和 `<select>` 之类的标签都非常相似—它们都接受一个 `value` 属性，你可以使用它来实现受控组件。

## 4. 多个输入的解决方案 

当需要处理多个 `input` 元素时，我们可以给每个元素添加 `name` 属性，并让处理函数根据 `event.target.name` 的值选择要执行的操作。

```react
import React, {Component} from 'react';

export default class Reservation extends Component {
    constructor(props) {
      super(props);
      this.state = {
        username: '',
        password: ''
      };
    }
  
    handleChange(event) {
        let name  = event.target.name; 
        let value = event.target.value;
        this.setState({
            [name]: value
        })
    }
  
    render() {
      return (
        <form>
            <label>账号：</label>
            <input type='text' name='username' onChange={this.handleChange.bind(this)} />

            <br />

            <label>密码：</label>
            <input type='password' name='password' onChange={this.handleChange.bind(this)} />

            <p>账号：{this.state.username} <br/> 密码：{this.state.password}</p>
        </form>
      );
    }
  }
```

演示效果：

![](IMGS/more-input.gif)

## 5. 受控输入空值

在受控组件上指定 `value` 的 prop 会阻止用户更改输入。如果你指定了 `value`，但输入仍可编辑，则可能是你意外地将 `value` 设置为 `undefined` 或 `null`。

下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）

```jsx
ReactDOM.createRoot(mountNode).render(<input value="hi" />);

setTimeout(function() {
  ReactDOM.createRoot(mountNode).render(<input value={null} />);
}, 1000);
```

# 三、非受控组件

在大多数情况下，我们推荐使用 [受控组件](https://zh-hans.reactjs.org/docs/forms.html#controlled-components) 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。

要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 [使用 ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html) 来从 DOM 节点中获取表单数据。

```react
import React from 'react';
export default class LoginBox extends React.Component {
  constructor(props) {
    super(props);
    this.username = React.createRef();
    this.password = React.createRef();
  }
  handleSubmit() {
    let username = this.username.current.value;
    let password = this.password.current.value;
    console.log(username, password);
  }
  render() {
    return (
      <form>
        <input type='text' ref={this.username}></input>
        <input type='password' ref={this.password}></input>
        <button type='button' onClick={this.handleSubmit.bind(this)}>登录</button>
      </form>
    );
  }
}
```

因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。

## 默认值

在 React 渲染生命周期时，表单元素上的 `value` 将会覆盖 DOM 节点中的值。在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 `defaultValue` 属性，而不是 `value`。在一个组件已经挂载之后去更新 `defaultValue` 属性的值，不会造成 DOM 上值的任何更新。

```react
render() {
  return (
    <form>
      <input type='text' ref={this.username} defaultValue="admin"></input>
      <input type='password' ref={this.password} defaultValue="123456"></input>
      <button type='button' onClick={this.handleSubmit.bind(this)}>登录</button>
    </form>
  );
}
```

同样，`<input type="checkbox">` 和 `<input type="radio">` 支持 `defaultChecked`，`<select>` 和 `<textarea>` 支持 `defaultValue`.

























